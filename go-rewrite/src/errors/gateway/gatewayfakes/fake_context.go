// Code generated by counterfeiter. DO NOT EDIT.
package gatewayfakes

import (
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"sync"

	echo "github.com/labstack/echo/v4"
)

type FakeContext struct {
	AttachmentStub        func(string, string) error
	attachmentMutex       sync.RWMutex
	attachmentArgsForCall []struct {
		arg1 string
		arg2 string
	}
	attachmentReturns struct {
		result1 error
	}
	attachmentReturnsOnCall map[int]struct {
		result1 error
	}
	BindStub        func(interface{}) error
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		arg1 interface{}
	}
	bindReturns struct {
		result1 error
	}
	bindReturnsOnCall map[int]struct {
		result1 error
	}
	BlobStub        func(int, string, []byte) error
	blobMutex       sync.RWMutex
	blobArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 []byte
	}
	blobReturns struct {
		result1 error
	}
	blobReturnsOnCall map[int]struct {
		result1 error
	}
	CookieStub        func(string) (*http.Cookie, error)
	cookieMutex       sync.RWMutex
	cookieArgsForCall []struct {
		arg1 string
	}
	cookieReturns struct {
		result1 *http.Cookie
		result2 error
	}
	cookieReturnsOnCall map[int]struct {
		result1 *http.Cookie
		result2 error
	}
	CookiesStub        func() []*http.Cookie
	cookiesMutex       sync.RWMutex
	cookiesArgsForCall []struct {
	}
	cookiesReturns struct {
		result1 []*http.Cookie
	}
	cookiesReturnsOnCall map[int]struct {
		result1 []*http.Cookie
	}
	EchoStub        func() *echo.Echo
	echoMutex       sync.RWMutex
	echoArgsForCall []struct {
	}
	echoReturns struct {
		result1 *echo.Echo
	}
	echoReturnsOnCall map[int]struct {
		result1 *echo.Echo
	}
	ErrorStub        func(error)
	errorMutex       sync.RWMutex
	errorArgsForCall []struct {
		arg1 error
	}
	FileStub        func(string) error
	fileMutex       sync.RWMutex
	fileArgsForCall []struct {
		arg1 string
	}
	fileReturns struct {
		result1 error
	}
	fileReturnsOnCall map[int]struct {
		result1 error
	}
	FormFileStub        func(string) (*multipart.FileHeader, error)
	formFileMutex       sync.RWMutex
	formFileArgsForCall []struct {
		arg1 string
	}
	formFileReturns struct {
		result1 *multipart.FileHeader
		result2 error
	}
	formFileReturnsOnCall map[int]struct {
		result1 *multipart.FileHeader
		result2 error
	}
	FormParamsStub        func() (url.Values, error)
	formParamsMutex       sync.RWMutex
	formParamsArgsForCall []struct {
	}
	formParamsReturns struct {
		result1 url.Values
		result2 error
	}
	formParamsReturnsOnCall map[int]struct {
		result1 url.Values
		result2 error
	}
	FormValueStub        func(string) string
	formValueMutex       sync.RWMutex
	formValueArgsForCall []struct {
		arg1 string
	}
	formValueReturns struct {
		result1 string
	}
	formValueReturnsOnCall map[int]struct {
		result1 string
	}
	GetStub        func(string) interface{}
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 interface{}
	}
	getReturnsOnCall map[int]struct {
		result1 interface{}
	}
	HTMLStub        func(int, string) error
	hTMLMutex       sync.RWMutex
	hTMLArgsForCall []struct {
		arg1 int
		arg2 string
	}
	hTMLReturns struct {
		result1 error
	}
	hTMLReturnsOnCall map[int]struct {
		result1 error
	}
	HTMLBlobStub        func(int, []byte) error
	hTMLBlobMutex       sync.RWMutex
	hTMLBlobArgsForCall []struct {
		arg1 int
		arg2 []byte
	}
	hTMLBlobReturns struct {
		result1 error
	}
	hTMLBlobReturnsOnCall map[int]struct {
		result1 error
	}
	HandlerStub        func() echo.HandlerFunc
	handlerMutex       sync.RWMutex
	handlerArgsForCall []struct {
	}
	handlerReturns struct {
		result1 echo.HandlerFunc
	}
	handlerReturnsOnCall map[int]struct {
		result1 echo.HandlerFunc
	}
	InlineStub        func(string, string) error
	inlineMutex       sync.RWMutex
	inlineArgsForCall []struct {
		arg1 string
		arg2 string
	}
	inlineReturns struct {
		result1 error
	}
	inlineReturnsOnCall map[int]struct {
		result1 error
	}
	IsTLSStub        func() bool
	isTLSMutex       sync.RWMutex
	isTLSArgsForCall []struct {
	}
	isTLSReturns struct {
		result1 bool
	}
	isTLSReturnsOnCall map[int]struct {
		result1 bool
	}
	IsWebSocketStub        func() bool
	isWebSocketMutex       sync.RWMutex
	isWebSocketArgsForCall []struct {
	}
	isWebSocketReturns struct {
		result1 bool
	}
	isWebSocketReturnsOnCall map[int]struct {
		result1 bool
	}
	JSONStub        func(int, interface{}) error
	jSONMutex       sync.RWMutex
	jSONArgsForCall []struct {
		arg1 int
		arg2 interface{}
	}
	jSONReturns struct {
		result1 error
	}
	jSONReturnsOnCall map[int]struct {
		result1 error
	}
	JSONBlobStub        func(int, []byte) error
	jSONBlobMutex       sync.RWMutex
	jSONBlobArgsForCall []struct {
		arg1 int
		arg2 []byte
	}
	jSONBlobReturns struct {
		result1 error
	}
	jSONBlobReturnsOnCall map[int]struct {
		result1 error
	}
	JSONPStub        func(int, string, interface{}) error
	jSONPMutex       sync.RWMutex
	jSONPArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 interface{}
	}
	jSONPReturns struct {
		result1 error
	}
	jSONPReturnsOnCall map[int]struct {
		result1 error
	}
	JSONPBlobStub        func(int, string, []byte) error
	jSONPBlobMutex       sync.RWMutex
	jSONPBlobArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 []byte
	}
	jSONPBlobReturns struct {
		result1 error
	}
	jSONPBlobReturnsOnCall map[int]struct {
		result1 error
	}
	JSONPrettyStub        func(int, interface{}, string) error
	jSONPrettyMutex       sync.RWMutex
	jSONPrettyArgsForCall []struct {
		arg1 int
		arg2 interface{}
		arg3 string
	}
	jSONPrettyReturns struct {
		result1 error
	}
	jSONPrettyReturnsOnCall map[int]struct {
		result1 error
	}
	LoggerStub        func() echo.Logger
	loggerMutex       sync.RWMutex
	loggerArgsForCall []struct {
	}
	loggerReturns struct {
		result1 echo.Logger
	}
	loggerReturnsOnCall map[int]struct {
		result1 echo.Logger
	}
	MultipartFormStub        func() (*multipart.Form, error)
	multipartFormMutex       sync.RWMutex
	multipartFormArgsForCall []struct {
	}
	multipartFormReturns struct {
		result1 *multipart.Form
		result2 error
	}
	multipartFormReturnsOnCall map[int]struct {
		result1 *multipart.Form
		result2 error
	}
	NoContentStub        func(int) error
	noContentMutex       sync.RWMutex
	noContentArgsForCall []struct {
		arg1 int
	}
	noContentReturns struct {
		result1 error
	}
	noContentReturnsOnCall map[int]struct {
		result1 error
	}
	ParamStub        func(string) string
	paramMutex       sync.RWMutex
	paramArgsForCall []struct {
		arg1 string
	}
	paramReturns struct {
		result1 string
	}
	paramReturnsOnCall map[int]struct {
		result1 string
	}
	ParamNamesStub        func() []string
	paramNamesMutex       sync.RWMutex
	paramNamesArgsForCall []struct {
	}
	paramNamesReturns struct {
		result1 []string
	}
	paramNamesReturnsOnCall map[int]struct {
		result1 []string
	}
	ParamValuesStub        func() []string
	paramValuesMutex       sync.RWMutex
	paramValuesArgsForCall []struct {
	}
	paramValuesReturns struct {
		result1 []string
	}
	paramValuesReturnsOnCall map[int]struct {
		result1 []string
	}
	PathStub        func() string
	pathMutex       sync.RWMutex
	pathArgsForCall []struct {
	}
	pathReturns struct {
		result1 string
	}
	pathReturnsOnCall map[int]struct {
		result1 string
	}
	QueryParamStub        func(string) string
	queryParamMutex       sync.RWMutex
	queryParamArgsForCall []struct {
		arg1 string
	}
	queryParamReturns struct {
		result1 string
	}
	queryParamReturnsOnCall map[int]struct {
		result1 string
	}
	QueryParamsStub        func() url.Values
	queryParamsMutex       sync.RWMutex
	queryParamsArgsForCall []struct {
	}
	queryParamsReturns struct {
		result1 url.Values
	}
	queryParamsReturnsOnCall map[int]struct {
		result1 url.Values
	}
	QueryStringStub        func() string
	queryStringMutex       sync.RWMutex
	queryStringArgsForCall []struct {
	}
	queryStringReturns struct {
		result1 string
	}
	queryStringReturnsOnCall map[int]struct {
		result1 string
	}
	RealIPStub        func() string
	realIPMutex       sync.RWMutex
	realIPArgsForCall []struct {
	}
	realIPReturns struct {
		result1 string
	}
	realIPReturnsOnCall map[int]struct {
		result1 string
	}
	RedirectStub        func(int, string) error
	redirectMutex       sync.RWMutex
	redirectArgsForCall []struct {
		arg1 int
		arg2 string
	}
	redirectReturns struct {
		result1 error
	}
	redirectReturnsOnCall map[int]struct {
		result1 error
	}
	RenderStub        func(int, string, interface{}) error
	renderMutex       sync.RWMutex
	renderArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 interface{}
	}
	renderReturns struct {
		result1 error
	}
	renderReturnsOnCall map[int]struct {
		result1 error
	}
	RequestStub        func() *http.Request
	requestMutex       sync.RWMutex
	requestArgsForCall []struct {
	}
	requestReturns struct {
		result1 *http.Request
	}
	requestReturnsOnCall map[int]struct {
		result1 *http.Request
	}
	ResetStub        func(*http.Request, http.ResponseWriter)
	resetMutex       sync.RWMutex
	resetArgsForCall []struct {
		arg1 *http.Request
		arg2 http.ResponseWriter
	}
	ResponseStub        func() *echo.Response
	responseMutex       sync.RWMutex
	responseArgsForCall []struct {
	}
	responseReturns struct {
		result1 *echo.Response
	}
	responseReturnsOnCall map[int]struct {
		result1 *echo.Response
	}
	SchemeStub        func() string
	schemeMutex       sync.RWMutex
	schemeArgsForCall []struct {
	}
	schemeReturns struct {
		result1 string
	}
	schemeReturnsOnCall map[int]struct {
		result1 string
	}
	SetStub        func(string, interface{})
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	SetCookieStub        func(*http.Cookie)
	setCookieMutex       sync.RWMutex
	setCookieArgsForCall []struct {
		arg1 *http.Cookie
	}
	SetHandlerStub        func(echo.HandlerFunc)
	setHandlerMutex       sync.RWMutex
	setHandlerArgsForCall []struct {
		arg1 echo.HandlerFunc
	}
	SetLoggerStub        func(echo.Logger)
	setLoggerMutex       sync.RWMutex
	setLoggerArgsForCall []struct {
		arg1 echo.Logger
	}
	SetParamNamesStub        func(...string)
	setParamNamesMutex       sync.RWMutex
	setParamNamesArgsForCall []struct {
		arg1 []string
	}
	SetParamValuesStub        func(...string)
	setParamValuesMutex       sync.RWMutex
	setParamValuesArgsForCall []struct {
		arg1 []string
	}
	SetPathStub        func(string)
	setPathMutex       sync.RWMutex
	setPathArgsForCall []struct {
		arg1 string
	}
	SetRequestStub        func(*http.Request)
	setRequestMutex       sync.RWMutex
	setRequestArgsForCall []struct {
		arg1 *http.Request
	}
	SetResponseStub        func(*echo.Response)
	setResponseMutex       sync.RWMutex
	setResponseArgsForCall []struct {
		arg1 *echo.Response
	}
	StreamStub        func(int, string, io.Reader) error
	streamMutex       sync.RWMutex
	streamArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 io.Reader
	}
	streamReturns struct {
		result1 error
	}
	streamReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func(int, string) error
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
		arg1 int
		arg2 string
	}
	stringReturns struct {
		result1 error
	}
	stringReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateStub        func(interface{}) error
	validateMutex       sync.RWMutex
	validateArgsForCall []struct {
		arg1 interface{}
	}
	validateReturns struct {
		result1 error
	}
	validateReturnsOnCall map[int]struct {
		result1 error
	}
	XMLStub        func(int, interface{}) error
	xMLMutex       sync.RWMutex
	xMLArgsForCall []struct {
		arg1 int
		arg2 interface{}
	}
	xMLReturns struct {
		result1 error
	}
	xMLReturnsOnCall map[int]struct {
		result1 error
	}
	XMLBlobStub        func(int, []byte) error
	xMLBlobMutex       sync.RWMutex
	xMLBlobArgsForCall []struct {
		arg1 int
		arg2 []byte
	}
	xMLBlobReturns struct {
		result1 error
	}
	xMLBlobReturnsOnCall map[int]struct {
		result1 error
	}
	XMLPrettyStub        func(int, interface{}, string) error
	xMLPrettyMutex       sync.RWMutex
	xMLPrettyArgsForCall []struct {
		arg1 int
		arg2 interface{}
		arg3 string
	}
	xMLPrettyReturns struct {
		result1 error
	}
	xMLPrettyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeContext) Attachment(arg1 string, arg2 string) error {
	fake.attachmentMutex.Lock()
	ret, specificReturn := fake.attachmentReturnsOnCall[len(fake.attachmentArgsForCall)]
	fake.attachmentArgsForCall = append(fake.attachmentArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.AttachmentStub
	fakeReturns := fake.attachmentReturns
	fake.recordInvocation("Attachment", []interface{}{arg1, arg2})
	fake.attachmentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) AttachmentCallCount() int {
	fake.attachmentMutex.RLock()
	defer fake.attachmentMutex.RUnlock()
	return len(fake.attachmentArgsForCall)
}

func (fake *FakeContext) AttachmentCalls(stub func(string, string) error) {
	fake.attachmentMutex.Lock()
	defer fake.attachmentMutex.Unlock()
	fake.AttachmentStub = stub
}

func (fake *FakeContext) AttachmentArgsForCall(i int) (string, string) {
	fake.attachmentMutex.RLock()
	defer fake.attachmentMutex.RUnlock()
	argsForCall := fake.attachmentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) AttachmentReturns(result1 error) {
	fake.attachmentMutex.Lock()
	defer fake.attachmentMutex.Unlock()
	fake.AttachmentStub = nil
	fake.attachmentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) AttachmentReturnsOnCall(i int, result1 error) {
	fake.attachmentMutex.Lock()
	defer fake.attachmentMutex.Unlock()
	fake.AttachmentStub = nil
	if fake.attachmentReturnsOnCall == nil {
		fake.attachmentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachmentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Bind(arg1 interface{}) error {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.BindStub
	fakeReturns := fake.bindReturns
	fake.recordInvocation("Bind", []interface{}{arg1})
	fake.bindMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakeContext) BindCalls(stub func(interface{}) error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = stub
}

func (fake *FakeContext) BindArgsForCall(i int) interface{} {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	argsForCall := fake.bindArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) BindReturns(result1 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) BindReturnsOnCall(i int, result1 error) {
	fake.bindMutex.Lock()
	defer fake.bindMutex.Unlock()
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Blob(arg1 int, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.blobMutex.Lock()
	ret, specificReturn := fake.blobReturnsOnCall[len(fake.blobArgsForCall)]
	fake.blobArgsForCall = append(fake.blobArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.BlobStub
	fakeReturns := fake.blobReturns
	fake.recordInvocation("Blob", []interface{}{arg1, arg2, arg3Copy})
	fake.blobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) BlobCallCount() int {
	fake.blobMutex.RLock()
	defer fake.blobMutex.RUnlock()
	return len(fake.blobArgsForCall)
}

func (fake *FakeContext) BlobCalls(stub func(int, string, []byte) error) {
	fake.blobMutex.Lock()
	defer fake.blobMutex.Unlock()
	fake.BlobStub = stub
}

func (fake *FakeContext) BlobArgsForCall(i int) (int, string, []byte) {
	fake.blobMutex.RLock()
	defer fake.blobMutex.RUnlock()
	argsForCall := fake.blobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) BlobReturns(result1 error) {
	fake.blobMutex.Lock()
	defer fake.blobMutex.Unlock()
	fake.BlobStub = nil
	fake.blobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) BlobReturnsOnCall(i int, result1 error) {
	fake.blobMutex.Lock()
	defer fake.blobMutex.Unlock()
	fake.BlobStub = nil
	if fake.blobReturnsOnCall == nil {
		fake.blobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.blobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Cookie(arg1 string) (*http.Cookie, error) {
	fake.cookieMutex.Lock()
	ret, specificReturn := fake.cookieReturnsOnCall[len(fake.cookieArgsForCall)]
	fake.cookieArgsForCall = append(fake.cookieArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CookieStub
	fakeReturns := fake.cookieReturns
	fake.recordInvocation("Cookie", []interface{}{arg1})
	fake.cookieMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContext) CookieCallCount() int {
	fake.cookieMutex.RLock()
	defer fake.cookieMutex.RUnlock()
	return len(fake.cookieArgsForCall)
}

func (fake *FakeContext) CookieCalls(stub func(string) (*http.Cookie, error)) {
	fake.cookieMutex.Lock()
	defer fake.cookieMutex.Unlock()
	fake.CookieStub = stub
}

func (fake *FakeContext) CookieArgsForCall(i int) string {
	fake.cookieMutex.RLock()
	defer fake.cookieMutex.RUnlock()
	argsForCall := fake.cookieArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) CookieReturns(result1 *http.Cookie, result2 error) {
	fake.cookieMutex.Lock()
	defer fake.cookieMutex.Unlock()
	fake.CookieStub = nil
	fake.cookieReturns = struct {
		result1 *http.Cookie
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) CookieReturnsOnCall(i int, result1 *http.Cookie, result2 error) {
	fake.cookieMutex.Lock()
	defer fake.cookieMutex.Unlock()
	fake.CookieStub = nil
	if fake.cookieReturnsOnCall == nil {
		fake.cookieReturnsOnCall = make(map[int]struct {
			result1 *http.Cookie
			result2 error
		})
	}
	fake.cookieReturnsOnCall[i] = struct {
		result1 *http.Cookie
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) Cookies() []*http.Cookie {
	fake.cookiesMutex.Lock()
	ret, specificReturn := fake.cookiesReturnsOnCall[len(fake.cookiesArgsForCall)]
	fake.cookiesArgsForCall = append(fake.cookiesArgsForCall, struct {
	}{})
	stub := fake.CookiesStub
	fakeReturns := fake.cookiesReturns
	fake.recordInvocation("Cookies", []interface{}{})
	fake.cookiesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) CookiesCallCount() int {
	fake.cookiesMutex.RLock()
	defer fake.cookiesMutex.RUnlock()
	return len(fake.cookiesArgsForCall)
}

func (fake *FakeContext) CookiesCalls(stub func() []*http.Cookie) {
	fake.cookiesMutex.Lock()
	defer fake.cookiesMutex.Unlock()
	fake.CookiesStub = stub
}

func (fake *FakeContext) CookiesReturns(result1 []*http.Cookie) {
	fake.cookiesMutex.Lock()
	defer fake.cookiesMutex.Unlock()
	fake.CookiesStub = nil
	fake.cookiesReturns = struct {
		result1 []*http.Cookie
	}{result1}
}

func (fake *FakeContext) CookiesReturnsOnCall(i int, result1 []*http.Cookie) {
	fake.cookiesMutex.Lock()
	defer fake.cookiesMutex.Unlock()
	fake.CookiesStub = nil
	if fake.cookiesReturnsOnCall == nil {
		fake.cookiesReturnsOnCall = make(map[int]struct {
			result1 []*http.Cookie
		})
	}
	fake.cookiesReturnsOnCall[i] = struct {
		result1 []*http.Cookie
	}{result1}
}

func (fake *FakeContext) Echo() *echo.Echo {
	fake.echoMutex.Lock()
	ret, specificReturn := fake.echoReturnsOnCall[len(fake.echoArgsForCall)]
	fake.echoArgsForCall = append(fake.echoArgsForCall, struct {
	}{})
	stub := fake.EchoStub
	fakeReturns := fake.echoReturns
	fake.recordInvocation("Echo", []interface{}{})
	fake.echoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) EchoCallCount() int {
	fake.echoMutex.RLock()
	defer fake.echoMutex.RUnlock()
	return len(fake.echoArgsForCall)
}

func (fake *FakeContext) EchoCalls(stub func() *echo.Echo) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = stub
}

func (fake *FakeContext) EchoReturns(result1 *echo.Echo) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = nil
	fake.echoReturns = struct {
		result1 *echo.Echo
	}{result1}
}

func (fake *FakeContext) EchoReturnsOnCall(i int, result1 *echo.Echo) {
	fake.echoMutex.Lock()
	defer fake.echoMutex.Unlock()
	fake.EchoStub = nil
	if fake.echoReturnsOnCall == nil {
		fake.echoReturnsOnCall = make(map[int]struct {
			result1 *echo.Echo
		})
	}
	fake.echoReturnsOnCall[i] = struct {
		result1 *echo.Echo
	}{result1}
}

func (fake *FakeContext) Error(arg1 error) {
	fake.errorMutex.Lock()
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct {
		arg1 error
	}{arg1})
	stub := fake.ErrorStub
	fake.recordInvocation("Error", []interface{}{arg1})
	fake.errorMutex.Unlock()
	if stub != nil {
		fake.ErrorStub(arg1)
	}
}

func (fake *FakeContext) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *FakeContext) ErrorCalls(stub func(error)) {
	fake.errorMutex.Lock()
	defer fake.errorMutex.Unlock()
	fake.ErrorStub = stub
}

func (fake *FakeContext) ErrorArgsForCall(i int) error {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	argsForCall := fake.errorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) File(arg1 string) error {
	fake.fileMutex.Lock()
	ret, specificReturn := fake.fileReturnsOnCall[len(fake.fileArgsForCall)]
	fake.fileArgsForCall = append(fake.fileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FileStub
	fakeReturns := fake.fileReturns
	fake.recordInvocation("File", []interface{}{arg1})
	fake.fileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) FileCallCount() int {
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	return len(fake.fileArgsForCall)
}

func (fake *FakeContext) FileCalls(stub func(string) error) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = stub
}

func (fake *FakeContext) FileArgsForCall(i int) string {
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	argsForCall := fake.fileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) FileReturns(result1 error) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = nil
	fake.fileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) FileReturnsOnCall(i int, result1 error) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = nil
	if fake.fileReturnsOnCall == nil {
		fake.fileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) FormFile(arg1 string) (*multipart.FileHeader, error) {
	fake.formFileMutex.Lock()
	ret, specificReturn := fake.formFileReturnsOnCall[len(fake.formFileArgsForCall)]
	fake.formFileArgsForCall = append(fake.formFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FormFileStub
	fakeReturns := fake.formFileReturns
	fake.recordInvocation("FormFile", []interface{}{arg1})
	fake.formFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContext) FormFileCallCount() int {
	fake.formFileMutex.RLock()
	defer fake.formFileMutex.RUnlock()
	return len(fake.formFileArgsForCall)
}

func (fake *FakeContext) FormFileCalls(stub func(string) (*multipart.FileHeader, error)) {
	fake.formFileMutex.Lock()
	defer fake.formFileMutex.Unlock()
	fake.FormFileStub = stub
}

func (fake *FakeContext) FormFileArgsForCall(i int) string {
	fake.formFileMutex.RLock()
	defer fake.formFileMutex.RUnlock()
	argsForCall := fake.formFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) FormFileReturns(result1 *multipart.FileHeader, result2 error) {
	fake.formFileMutex.Lock()
	defer fake.formFileMutex.Unlock()
	fake.FormFileStub = nil
	fake.formFileReturns = struct {
		result1 *multipart.FileHeader
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) FormFileReturnsOnCall(i int, result1 *multipart.FileHeader, result2 error) {
	fake.formFileMutex.Lock()
	defer fake.formFileMutex.Unlock()
	fake.FormFileStub = nil
	if fake.formFileReturnsOnCall == nil {
		fake.formFileReturnsOnCall = make(map[int]struct {
			result1 *multipart.FileHeader
			result2 error
		})
	}
	fake.formFileReturnsOnCall[i] = struct {
		result1 *multipart.FileHeader
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) FormParams() (url.Values, error) {
	fake.formParamsMutex.Lock()
	ret, specificReturn := fake.formParamsReturnsOnCall[len(fake.formParamsArgsForCall)]
	fake.formParamsArgsForCall = append(fake.formParamsArgsForCall, struct {
	}{})
	stub := fake.FormParamsStub
	fakeReturns := fake.formParamsReturns
	fake.recordInvocation("FormParams", []interface{}{})
	fake.formParamsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContext) FormParamsCallCount() int {
	fake.formParamsMutex.RLock()
	defer fake.formParamsMutex.RUnlock()
	return len(fake.formParamsArgsForCall)
}

func (fake *FakeContext) FormParamsCalls(stub func() (url.Values, error)) {
	fake.formParamsMutex.Lock()
	defer fake.formParamsMutex.Unlock()
	fake.FormParamsStub = stub
}

func (fake *FakeContext) FormParamsReturns(result1 url.Values, result2 error) {
	fake.formParamsMutex.Lock()
	defer fake.formParamsMutex.Unlock()
	fake.FormParamsStub = nil
	fake.formParamsReturns = struct {
		result1 url.Values
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) FormParamsReturnsOnCall(i int, result1 url.Values, result2 error) {
	fake.formParamsMutex.Lock()
	defer fake.formParamsMutex.Unlock()
	fake.FormParamsStub = nil
	if fake.formParamsReturnsOnCall == nil {
		fake.formParamsReturnsOnCall = make(map[int]struct {
			result1 url.Values
			result2 error
		})
	}
	fake.formParamsReturnsOnCall[i] = struct {
		result1 url.Values
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) FormValue(arg1 string) string {
	fake.formValueMutex.Lock()
	ret, specificReturn := fake.formValueReturnsOnCall[len(fake.formValueArgsForCall)]
	fake.formValueArgsForCall = append(fake.formValueArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FormValueStub
	fakeReturns := fake.formValueReturns
	fake.recordInvocation("FormValue", []interface{}{arg1})
	fake.formValueMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) FormValueCallCount() int {
	fake.formValueMutex.RLock()
	defer fake.formValueMutex.RUnlock()
	return len(fake.formValueArgsForCall)
}

func (fake *FakeContext) FormValueCalls(stub func(string) string) {
	fake.formValueMutex.Lock()
	defer fake.formValueMutex.Unlock()
	fake.FormValueStub = stub
}

func (fake *FakeContext) FormValueArgsForCall(i int) string {
	fake.formValueMutex.RLock()
	defer fake.formValueMutex.RUnlock()
	argsForCall := fake.formValueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) FormValueReturns(result1 string) {
	fake.formValueMutex.Lock()
	defer fake.formValueMutex.Unlock()
	fake.FormValueStub = nil
	fake.formValueReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) FormValueReturnsOnCall(i int, result1 string) {
	fake.formValueMutex.Lock()
	defer fake.formValueMutex.Unlock()
	fake.FormValueStub = nil
	if fake.formValueReturnsOnCall == nil {
		fake.formValueReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.formValueReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) Get(arg1 string) interface{} {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeContext) GetCalls(stub func(string) interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeContext) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) GetReturns(result1 interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeContext) GetReturnsOnCall(i int, result1 interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakeContext) HTML(arg1 int, arg2 string) error {
	fake.hTMLMutex.Lock()
	ret, specificReturn := fake.hTMLReturnsOnCall[len(fake.hTMLArgsForCall)]
	fake.hTMLArgsForCall = append(fake.hTMLArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.HTMLStub
	fakeReturns := fake.hTMLReturns
	fake.recordInvocation("HTML", []interface{}{arg1, arg2})
	fake.hTMLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) HTMLCallCount() int {
	fake.hTMLMutex.RLock()
	defer fake.hTMLMutex.RUnlock()
	return len(fake.hTMLArgsForCall)
}

func (fake *FakeContext) HTMLCalls(stub func(int, string) error) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = stub
}

func (fake *FakeContext) HTMLArgsForCall(i int) (int, string) {
	fake.hTMLMutex.RLock()
	defer fake.hTMLMutex.RUnlock()
	argsForCall := fake.hTMLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) HTMLReturns(result1 error) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = nil
	fake.hTMLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) HTMLReturnsOnCall(i int, result1 error) {
	fake.hTMLMutex.Lock()
	defer fake.hTMLMutex.Unlock()
	fake.HTMLStub = nil
	if fake.hTMLReturnsOnCall == nil {
		fake.hTMLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hTMLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) HTMLBlob(arg1 int, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.hTMLBlobMutex.Lock()
	ret, specificReturn := fake.hTMLBlobReturnsOnCall[len(fake.hTMLBlobArgsForCall)]
	fake.hTMLBlobArgsForCall = append(fake.hTMLBlobArgsForCall, struct {
		arg1 int
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.HTMLBlobStub
	fakeReturns := fake.hTMLBlobReturns
	fake.recordInvocation("HTMLBlob", []interface{}{arg1, arg2Copy})
	fake.hTMLBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) HTMLBlobCallCount() int {
	fake.hTMLBlobMutex.RLock()
	defer fake.hTMLBlobMutex.RUnlock()
	return len(fake.hTMLBlobArgsForCall)
}

func (fake *FakeContext) HTMLBlobCalls(stub func(int, []byte) error) {
	fake.hTMLBlobMutex.Lock()
	defer fake.hTMLBlobMutex.Unlock()
	fake.HTMLBlobStub = stub
}

func (fake *FakeContext) HTMLBlobArgsForCall(i int) (int, []byte) {
	fake.hTMLBlobMutex.RLock()
	defer fake.hTMLBlobMutex.RUnlock()
	argsForCall := fake.hTMLBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) HTMLBlobReturns(result1 error) {
	fake.hTMLBlobMutex.Lock()
	defer fake.hTMLBlobMutex.Unlock()
	fake.HTMLBlobStub = nil
	fake.hTMLBlobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) HTMLBlobReturnsOnCall(i int, result1 error) {
	fake.hTMLBlobMutex.Lock()
	defer fake.hTMLBlobMutex.Unlock()
	fake.HTMLBlobStub = nil
	if fake.hTMLBlobReturnsOnCall == nil {
		fake.hTMLBlobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hTMLBlobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Handler() echo.HandlerFunc {
	fake.handlerMutex.Lock()
	ret, specificReturn := fake.handlerReturnsOnCall[len(fake.handlerArgsForCall)]
	fake.handlerArgsForCall = append(fake.handlerArgsForCall, struct {
	}{})
	stub := fake.HandlerStub
	fakeReturns := fake.handlerReturns
	fake.recordInvocation("Handler", []interface{}{})
	fake.handlerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) HandlerCallCount() int {
	fake.handlerMutex.RLock()
	defer fake.handlerMutex.RUnlock()
	return len(fake.handlerArgsForCall)
}

func (fake *FakeContext) HandlerCalls(stub func() echo.HandlerFunc) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = stub
}

func (fake *FakeContext) HandlerReturns(result1 echo.HandlerFunc) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = nil
	fake.handlerReturns = struct {
		result1 echo.HandlerFunc
	}{result1}
}

func (fake *FakeContext) HandlerReturnsOnCall(i int, result1 echo.HandlerFunc) {
	fake.handlerMutex.Lock()
	defer fake.handlerMutex.Unlock()
	fake.HandlerStub = nil
	if fake.handlerReturnsOnCall == nil {
		fake.handlerReturnsOnCall = make(map[int]struct {
			result1 echo.HandlerFunc
		})
	}
	fake.handlerReturnsOnCall[i] = struct {
		result1 echo.HandlerFunc
	}{result1}
}

func (fake *FakeContext) Inline(arg1 string, arg2 string) error {
	fake.inlineMutex.Lock()
	ret, specificReturn := fake.inlineReturnsOnCall[len(fake.inlineArgsForCall)]
	fake.inlineArgsForCall = append(fake.inlineArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.InlineStub
	fakeReturns := fake.inlineReturns
	fake.recordInvocation("Inline", []interface{}{arg1, arg2})
	fake.inlineMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) InlineCallCount() int {
	fake.inlineMutex.RLock()
	defer fake.inlineMutex.RUnlock()
	return len(fake.inlineArgsForCall)
}

func (fake *FakeContext) InlineCalls(stub func(string, string) error) {
	fake.inlineMutex.Lock()
	defer fake.inlineMutex.Unlock()
	fake.InlineStub = stub
}

func (fake *FakeContext) InlineArgsForCall(i int) (string, string) {
	fake.inlineMutex.RLock()
	defer fake.inlineMutex.RUnlock()
	argsForCall := fake.inlineArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) InlineReturns(result1 error) {
	fake.inlineMutex.Lock()
	defer fake.inlineMutex.Unlock()
	fake.InlineStub = nil
	fake.inlineReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) InlineReturnsOnCall(i int, result1 error) {
	fake.inlineMutex.Lock()
	defer fake.inlineMutex.Unlock()
	fake.InlineStub = nil
	if fake.inlineReturnsOnCall == nil {
		fake.inlineReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.inlineReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) IsTLS() bool {
	fake.isTLSMutex.Lock()
	ret, specificReturn := fake.isTLSReturnsOnCall[len(fake.isTLSArgsForCall)]
	fake.isTLSArgsForCall = append(fake.isTLSArgsForCall, struct {
	}{})
	stub := fake.IsTLSStub
	fakeReturns := fake.isTLSReturns
	fake.recordInvocation("IsTLS", []interface{}{})
	fake.isTLSMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) IsTLSCallCount() int {
	fake.isTLSMutex.RLock()
	defer fake.isTLSMutex.RUnlock()
	return len(fake.isTLSArgsForCall)
}

func (fake *FakeContext) IsTLSCalls(stub func() bool) {
	fake.isTLSMutex.Lock()
	defer fake.isTLSMutex.Unlock()
	fake.IsTLSStub = stub
}

func (fake *FakeContext) IsTLSReturns(result1 bool) {
	fake.isTLSMutex.Lock()
	defer fake.isTLSMutex.Unlock()
	fake.IsTLSStub = nil
	fake.isTLSReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeContext) IsTLSReturnsOnCall(i int, result1 bool) {
	fake.isTLSMutex.Lock()
	defer fake.isTLSMutex.Unlock()
	fake.IsTLSStub = nil
	if fake.isTLSReturnsOnCall == nil {
		fake.isTLSReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isTLSReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeContext) IsWebSocket() bool {
	fake.isWebSocketMutex.Lock()
	ret, specificReturn := fake.isWebSocketReturnsOnCall[len(fake.isWebSocketArgsForCall)]
	fake.isWebSocketArgsForCall = append(fake.isWebSocketArgsForCall, struct {
	}{})
	stub := fake.IsWebSocketStub
	fakeReturns := fake.isWebSocketReturns
	fake.recordInvocation("IsWebSocket", []interface{}{})
	fake.isWebSocketMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) IsWebSocketCallCount() int {
	fake.isWebSocketMutex.RLock()
	defer fake.isWebSocketMutex.RUnlock()
	return len(fake.isWebSocketArgsForCall)
}

func (fake *FakeContext) IsWebSocketCalls(stub func() bool) {
	fake.isWebSocketMutex.Lock()
	defer fake.isWebSocketMutex.Unlock()
	fake.IsWebSocketStub = stub
}

func (fake *FakeContext) IsWebSocketReturns(result1 bool) {
	fake.isWebSocketMutex.Lock()
	defer fake.isWebSocketMutex.Unlock()
	fake.IsWebSocketStub = nil
	fake.isWebSocketReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeContext) IsWebSocketReturnsOnCall(i int, result1 bool) {
	fake.isWebSocketMutex.Lock()
	defer fake.isWebSocketMutex.Unlock()
	fake.IsWebSocketStub = nil
	if fake.isWebSocketReturnsOnCall == nil {
		fake.isWebSocketReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isWebSocketReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeContext) JSON(arg1 int, arg2 interface{}) error {
	fake.jSONMutex.Lock()
	ret, specificReturn := fake.jSONReturnsOnCall[len(fake.jSONArgsForCall)]
	fake.jSONArgsForCall = append(fake.jSONArgsForCall, struct {
		arg1 int
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.JSONStub
	fakeReturns := fake.jSONReturns
	fake.recordInvocation("JSON", []interface{}{arg1, arg2})
	fake.jSONMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) JSONCallCount() int {
	fake.jSONMutex.RLock()
	defer fake.jSONMutex.RUnlock()
	return len(fake.jSONArgsForCall)
}

func (fake *FakeContext) JSONCalls(stub func(int, interface{}) error) {
	fake.jSONMutex.Lock()
	defer fake.jSONMutex.Unlock()
	fake.JSONStub = stub
}

func (fake *FakeContext) JSONArgsForCall(i int) (int, interface{}) {
	fake.jSONMutex.RLock()
	defer fake.jSONMutex.RUnlock()
	argsForCall := fake.jSONArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) JSONReturns(result1 error) {
	fake.jSONMutex.Lock()
	defer fake.jSONMutex.Unlock()
	fake.JSONStub = nil
	fake.jSONReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONReturnsOnCall(i int, result1 error) {
	fake.jSONMutex.Lock()
	defer fake.jSONMutex.Unlock()
	fake.JSONStub = nil
	if fake.jSONReturnsOnCall == nil {
		fake.jSONReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONBlob(arg1 int, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.jSONBlobMutex.Lock()
	ret, specificReturn := fake.jSONBlobReturnsOnCall[len(fake.jSONBlobArgsForCall)]
	fake.jSONBlobArgsForCall = append(fake.jSONBlobArgsForCall, struct {
		arg1 int
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.JSONBlobStub
	fakeReturns := fake.jSONBlobReturns
	fake.recordInvocation("JSONBlob", []interface{}{arg1, arg2Copy})
	fake.jSONBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) JSONBlobCallCount() int {
	fake.jSONBlobMutex.RLock()
	defer fake.jSONBlobMutex.RUnlock()
	return len(fake.jSONBlobArgsForCall)
}

func (fake *FakeContext) JSONBlobCalls(stub func(int, []byte) error) {
	fake.jSONBlobMutex.Lock()
	defer fake.jSONBlobMutex.Unlock()
	fake.JSONBlobStub = stub
}

func (fake *FakeContext) JSONBlobArgsForCall(i int) (int, []byte) {
	fake.jSONBlobMutex.RLock()
	defer fake.jSONBlobMutex.RUnlock()
	argsForCall := fake.jSONBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) JSONBlobReturns(result1 error) {
	fake.jSONBlobMutex.Lock()
	defer fake.jSONBlobMutex.Unlock()
	fake.JSONBlobStub = nil
	fake.jSONBlobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONBlobReturnsOnCall(i int, result1 error) {
	fake.jSONBlobMutex.Lock()
	defer fake.jSONBlobMutex.Unlock()
	fake.JSONBlobStub = nil
	if fake.jSONBlobReturnsOnCall == nil {
		fake.jSONBlobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONBlobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONP(arg1 int, arg2 string, arg3 interface{}) error {
	fake.jSONPMutex.Lock()
	ret, specificReturn := fake.jSONPReturnsOnCall[len(fake.jSONPArgsForCall)]
	fake.jSONPArgsForCall = append(fake.jSONPArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.JSONPStub
	fakeReturns := fake.jSONPReturns
	fake.recordInvocation("JSONP", []interface{}{arg1, arg2, arg3})
	fake.jSONPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) JSONPCallCount() int {
	fake.jSONPMutex.RLock()
	defer fake.jSONPMutex.RUnlock()
	return len(fake.jSONPArgsForCall)
}

func (fake *FakeContext) JSONPCalls(stub func(int, string, interface{}) error) {
	fake.jSONPMutex.Lock()
	defer fake.jSONPMutex.Unlock()
	fake.JSONPStub = stub
}

func (fake *FakeContext) JSONPArgsForCall(i int) (int, string, interface{}) {
	fake.jSONPMutex.RLock()
	defer fake.jSONPMutex.RUnlock()
	argsForCall := fake.jSONPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) JSONPReturns(result1 error) {
	fake.jSONPMutex.Lock()
	defer fake.jSONPMutex.Unlock()
	fake.JSONPStub = nil
	fake.jSONPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONPReturnsOnCall(i int, result1 error) {
	fake.jSONPMutex.Lock()
	defer fake.jSONPMutex.Unlock()
	fake.JSONPStub = nil
	if fake.jSONPReturnsOnCall == nil {
		fake.jSONPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONPBlob(arg1 int, arg2 string, arg3 []byte) error {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.jSONPBlobMutex.Lock()
	ret, specificReturn := fake.jSONPBlobReturnsOnCall[len(fake.jSONPBlobArgsForCall)]
	fake.jSONPBlobArgsForCall = append(fake.jSONPBlobArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 []byte
	}{arg1, arg2, arg3Copy})
	stub := fake.JSONPBlobStub
	fakeReturns := fake.jSONPBlobReturns
	fake.recordInvocation("JSONPBlob", []interface{}{arg1, arg2, arg3Copy})
	fake.jSONPBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) JSONPBlobCallCount() int {
	fake.jSONPBlobMutex.RLock()
	defer fake.jSONPBlobMutex.RUnlock()
	return len(fake.jSONPBlobArgsForCall)
}

func (fake *FakeContext) JSONPBlobCalls(stub func(int, string, []byte) error) {
	fake.jSONPBlobMutex.Lock()
	defer fake.jSONPBlobMutex.Unlock()
	fake.JSONPBlobStub = stub
}

func (fake *FakeContext) JSONPBlobArgsForCall(i int) (int, string, []byte) {
	fake.jSONPBlobMutex.RLock()
	defer fake.jSONPBlobMutex.RUnlock()
	argsForCall := fake.jSONPBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) JSONPBlobReturns(result1 error) {
	fake.jSONPBlobMutex.Lock()
	defer fake.jSONPBlobMutex.Unlock()
	fake.JSONPBlobStub = nil
	fake.jSONPBlobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONPBlobReturnsOnCall(i int, result1 error) {
	fake.jSONPBlobMutex.Lock()
	defer fake.jSONPBlobMutex.Unlock()
	fake.JSONPBlobStub = nil
	if fake.jSONPBlobReturnsOnCall == nil {
		fake.jSONPBlobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONPBlobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONPretty(arg1 int, arg2 interface{}, arg3 string) error {
	fake.jSONPrettyMutex.Lock()
	ret, specificReturn := fake.jSONPrettyReturnsOnCall[len(fake.jSONPrettyArgsForCall)]
	fake.jSONPrettyArgsForCall = append(fake.jSONPrettyArgsForCall, struct {
		arg1 int
		arg2 interface{}
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.JSONPrettyStub
	fakeReturns := fake.jSONPrettyReturns
	fake.recordInvocation("JSONPretty", []interface{}{arg1, arg2, arg3})
	fake.jSONPrettyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) JSONPrettyCallCount() int {
	fake.jSONPrettyMutex.RLock()
	defer fake.jSONPrettyMutex.RUnlock()
	return len(fake.jSONPrettyArgsForCall)
}

func (fake *FakeContext) JSONPrettyCalls(stub func(int, interface{}, string) error) {
	fake.jSONPrettyMutex.Lock()
	defer fake.jSONPrettyMutex.Unlock()
	fake.JSONPrettyStub = stub
}

func (fake *FakeContext) JSONPrettyArgsForCall(i int) (int, interface{}, string) {
	fake.jSONPrettyMutex.RLock()
	defer fake.jSONPrettyMutex.RUnlock()
	argsForCall := fake.jSONPrettyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) JSONPrettyReturns(result1 error) {
	fake.jSONPrettyMutex.Lock()
	defer fake.jSONPrettyMutex.Unlock()
	fake.JSONPrettyStub = nil
	fake.jSONPrettyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) JSONPrettyReturnsOnCall(i int, result1 error) {
	fake.jSONPrettyMutex.Lock()
	defer fake.jSONPrettyMutex.Unlock()
	fake.JSONPrettyStub = nil
	if fake.jSONPrettyReturnsOnCall == nil {
		fake.jSONPrettyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONPrettyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Logger() echo.Logger {
	fake.loggerMutex.Lock()
	ret, specificReturn := fake.loggerReturnsOnCall[len(fake.loggerArgsForCall)]
	fake.loggerArgsForCall = append(fake.loggerArgsForCall, struct {
	}{})
	stub := fake.LoggerStub
	fakeReturns := fake.loggerReturns
	fake.recordInvocation("Logger", []interface{}{})
	fake.loggerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) LoggerCallCount() int {
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	return len(fake.loggerArgsForCall)
}

func (fake *FakeContext) LoggerCalls(stub func() echo.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = stub
}

func (fake *FakeContext) LoggerReturns(result1 echo.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = nil
	fake.loggerReturns = struct {
		result1 echo.Logger
	}{result1}
}

func (fake *FakeContext) LoggerReturnsOnCall(i int, result1 echo.Logger) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = nil
	if fake.loggerReturnsOnCall == nil {
		fake.loggerReturnsOnCall = make(map[int]struct {
			result1 echo.Logger
		})
	}
	fake.loggerReturnsOnCall[i] = struct {
		result1 echo.Logger
	}{result1}
}

func (fake *FakeContext) MultipartForm() (*multipart.Form, error) {
	fake.multipartFormMutex.Lock()
	ret, specificReturn := fake.multipartFormReturnsOnCall[len(fake.multipartFormArgsForCall)]
	fake.multipartFormArgsForCall = append(fake.multipartFormArgsForCall, struct {
	}{})
	stub := fake.MultipartFormStub
	fakeReturns := fake.multipartFormReturns
	fake.recordInvocation("MultipartForm", []interface{}{})
	fake.multipartFormMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeContext) MultipartFormCallCount() int {
	fake.multipartFormMutex.RLock()
	defer fake.multipartFormMutex.RUnlock()
	return len(fake.multipartFormArgsForCall)
}

func (fake *FakeContext) MultipartFormCalls(stub func() (*multipart.Form, error)) {
	fake.multipartFormMutex.Lock()
	defer fake.multipartFormMutex.Unlock()
	fake.MultipartFormStub = stub
}

func (fake *FakeContext) MultipartFormReturns(result1 *multipart.Form, result2 error) {
	fake.multipartFormMutex.Lock()
	defer fake.multipartFormMutex.Unlock()
	fake.MultipartFormStub = nil
	fake.multipartFormReturns = struct {
		result1 *multipart.Form
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) MultipartFormReturnsOnCall(i int, result1 *multipart.Form, result2 error) {
	fake.multipartFormMutex.Lock()
	defer fake.multipartFormMutex.Unlock()
	fake.MultipartFormStub = nil
	if fake.multipartFormReturnsOnCall == nil {
		fake.multipartFormReturnsOnCall = make(map[int]struct {
			result1 *multipart.Form
			result2 error
		})
	}
	fake.multipartFormReturnsOnCall[i] = struct {
		result1 *multipart.Form
		result2 error
	}{result1, result2}
}

func (fake *FakeContext) NoContent(arg1 int) error {
	fake.noContentMutex.Lock()
	ret, specificReturn := fake.noContentReturnsOnCall[len(fake.noContentArgsForCall)]
	fake.noContentArgsForCall = append(fake.noContentArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.NoContentStub
	fakeReturns := fake.noContentReturns
	fake.recordInvocation("NoContent", []interface{}{arg1})
	fake.noContentMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) NoContentCallCount() int {
	fake.noContentMutex.RLock()
	defer fake.noContentMutex.RUnlock()
	return len(fake.noContentArgsForCall)
}

func (fake *FakeContext) NoContentCalls(stub func(int) error) {
	fake.noContentMutex.Lock()
	defer fake.noContentMutex.Unlock()
	fake.NoContentStub = stub
}

func (fake *FakeContext) NoContentArgsForCall(i int) int {
	fake.noContentMutex.RLock()
	defer fake.noContentMutex.RUnlock()
	argsForCall := fake.noContentArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) NoContentReturns(result1 error) {
	fake.noContentMutex.Lock()
	defer fake.noContentMutex.Unlock()
	fake.NoContentStub = nil
	fake.noContentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) NoContentReturnsOnCall(i int, result1 error) {
	fake.noContentMutex.Lock()
	defer fake.noContentMutex.Unlock()
	fake.NoContentStub = nil
	if fake.noContentReturnsOnCall == nil {
		fake.noContentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.noContentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Param(arg1 string) string {
	fake.paramMutex.Lock()
	ret, specificReturn := fake.paramReturnsOnCall[len(fake.paramArgsForCall)]
	fake.paramArgsForCall = append(fake.paramArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ParamStub
	fakeReturns := fake.paramReturns
	fake.recordInvocation("Param", []interface{}{arg1})
	fake.paramMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) ParamCallCount() int {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	return len(fake.paramArgsForCall)
}

func (fake *FakeContext) ParamCalls(stub func(string) string) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = stub
}

func (fake *FakeContext) ParamArgsForCall(i int) string {
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	argsForCall := fake.paramArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) ParamReturns(result1 string) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	fake.paramReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) ParamReturnsOnCall(i int, result1 string) {
	fake.paramMutex.Lock()
	defer fake.paramMutex.Unlock()
	fake.ParamStub = nil
	if fake.paramReturnsOnCall == nil {
		fake.paramReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.paramReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) ParamNames() []string {
	fake.paramNamesMutex.Lock()
	ret, specificReturn := fake.paramNamesReturnsOnCall[len(fake.paramNamesArgsForCall)]
	fake.paramNamesArgsForCall = append(fake.paramNamesArgsForCall, struct {
	}{})
	stub := fake.ParamNamesStub
	fakeReturns := fake.paramNamesReturns
	fake.recordInvocation("ParamNames", []interface{}{})
	fake.paramNamesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) ParamNamesCallCount() int {
	fake.paramNamesMutex.RLock()
	defer fake.paramNamesMutex.RUnlock()
	return len(fake.paramNamesArgsForCall)
}

func (fake *FakeContext) ParamNamesCalls(stub func() []string) {
	fake.paramNamesMutex.Lock()
	defer fake.paramNamesMutex.Unlock()
	fake.ParamNamesStub = stub
}

func (fake *FakeContext) ParamNamesReturns(result1 []string) {
	fake.paramNamesMutex.Lock()
	defer fake.paramNamesMutex.Unlock()
	fake.ParamNamesStub = nil
	fake.paramNamesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeContext) ParamNamesReturnsOnCall(i int, result1 []string) {
	fake.paramNamesMutex.Lock()
	defer fake.paramNamesMutex.Unlock()
	fake.ParamNamesStub = nil
	if fake.paramNamesReturnsOnCall == nil {
		fake.paramNamesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.paramNamesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeContext) ParamValues() []string {
	fake.paramValuesMutex.Lock()
	ret, specificReturn := fake.paramValuesReturnsOnCall[len(fake.paramValuesArgsForCall)]
	fake.paramValuesArgsForCall = append(fake.paramValuesArgsForCall, struct {
	}{})
	stub := fake.ParamValuesStub
	fakeReturns := fake.paramValuesReturns
	fake.recordInvocation("ParamValues", []interface{}{})
	fake.paramValuesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) ParamValuesCallCount() int {
	fake.paramValuesMutex.RLock()
	defer fake.paramValuesMutex.RUnlock()
	return len(fake.paramValuesArgsForCall)
}

func (fake *FakeContext) ParamValuesCalls(stub func() []string) {
	fake.paramValuesMutex.Lock()
	defer fake.paramValuesMutex.Unlock()
	fake.ParamValuesStub = stub
}

func (fake *FakeContext) ParamValuesReturns(result1 []string) {
	fake.paramValuesMutex.Lock()
	defer fake.paramValuesMutex.Unlock()
	fake.ParamValuesStub = nil
	fake.paramValuesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeContext) ParamValuesReturnsOnCall(i int, result1 []string) {
	fake.paramValuesMutex.Lock()
	defer fake.paramValuesMutex.Unlock()
	fake.ParamValuesStub = nil
	if fake.paramValuesReturnsOnCall == nil {
		fake.paramValuesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.paramValuesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeContext) Path() string {
	fake.pathMutex.Lock()
	ret, specificReturn := fake.pathReturnsOnCall[len(fake.pathArgsForCall)]
	fake.pathArgsForCall = append(fake.pathArgsForCall, struct {
	}{})
	stub := fake.PathStub
	fakeReturns := fake.pathReturns
	fake.recordInvocation("Path", []interface{}{})
	fake.pathMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) PathCallCount() int {
	fake.pathMutex.RLock()
	defer fake.pathMutex.RUnlock()
	return len(fake.pathArgsForCall)
}

func (fake *FakeContext) PathCalls(stub func() string) {
	fake.pathMutex.Lock()
	defer fake.pathMutex.Unlock()
	fake.PathStub = stub
}

func (fake *FakeContext) PathReturns(result1 string) {
	fake.pathMutex.Lock()
	defer fake.pathMutex.Unlock()
	fake.PathStub = nil
	fake.pathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) PathReturnsOnCall(i int, result1 string) {
	fake.pathMutex.Lock()
	defer fake.pathMutex.Unlock()
	fake.PathStub = nil
	if fake.pathReturnsOnCall == nil {
		fake.pathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) QueryParam(arg1 string) string {
	fake.queryParamMutex.Lock()
	ret, specificReturn := fake.queryParamReturnsOnCall[len(fake.queryParamArgsForCall)]
	fake.queryParamArgsForCall = append(fake.queryParamArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QueryParamStub
	fakeReturns := fake.queryParamReturns
	fake.recordInvocation("QueryParam", []interface{}{arg1})
	fake.queryParamMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) QueryParamCallCount() int {
	fake.queryParamMutex.RLock()
	defer fake.queryParamMutex.RUnlock()
	return len(fake.queryParamArgsForCall)
}

func (fake *FakeContext) QueryParamCalls(stub func(string) string) {
	fake.queryParamMutex.Lock()
	defer fake.queryParamMutex.Unlock()
	fake.QueryParamStub = stub
}

func (fake *FakeContext) QueryParamArgsForCall(i int) string {
	fake.queryParamMutex.RLock()
	defer fake.queryParamMutex.RUnlock()
	argsForCall := fake.queryParamArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) QueryParamReturns(result1 string) {
	fake.queryParamMutex.Lock()
	defer fake.queryParamMutex.Unlock()
	fake.QueryParamStub = nil
	fake.queryParamReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) QueryParamReturnsOnCall(i int, result1 string) {
	fake.queryParamMutex.Lock()
	defer fake.queryParamMutex.Unlock()
	fake.QueryParamStub = nil
	if fake.queryParamReturnsOnCall == nil {
		fake.queryParamReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.queryParamReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) QueryParams() url.Values {
	fake.queryParamsMutex.Lock()
	ret, specificReturn := fake.queryParamsReturnsOnCall[len(fake.queryParamsArgsForCall)]
	fake.queryParamsArgsForCall = append(fake.queryParamsArgsForCall, struct {
	}{})
	stub := fake.QueryParamsStub
	fakeReturns := fake.queryParamsReturns
	fake.recordInvocation("QueryParams", []interface{}{})
	fake.queryParamsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) QueryParamsCallCount() int {
	fake.queryParamsMutex.RLock()
	defer fake.queryParamsMutex.RUnlock()
	return len(fake.queryParamsArgsForCall)
}

func (fake *FakeContext) QueryParamsCalls(stub func() url.Values) {
	fake.queryParamsMutex.Lock()
	defer fake.queryParamsMutex.Unlock()
	fake.QueryParamsStub = stub
}

func (fake *FakeContext) QueryParamsReturns(result1 url.Values) {
	fake.queryParamsMutex.Lock()
	defer fake.queryParamsMutex.Unlock()
	fake.QueryParamsStub = nil
	fake.queryParamsReturns = struct {
		result1 url.Values
	}{result1}
}

func (fake *FakeContext) QueryParamsReturnsOnCall(i int, result1 url.Values) {
	fake.queryParamsMutex.Lock()
	defer fake.queryParamsMutex.Unlock()
	fake.QueryParamsStub = nil
	if fake.queryParamsReturnsOnCall == nil {
		fake.queryParamsReturnsOnCall = make(map[int]struct {
			result1 url.Values
		})
	}
	fake.queryParamsReturnsOnCall[i] = struct {
		result1 url.Values
	}{result1}
}

func (fake *FakeContext) QueryString() string {
	fake.queryStringMutex.Lock()
	ret, specificReturn := fake.queryStringReturnsOnCall[len(fake.queryStringArgsForCall)]
	fake.queryStringArgsForCall = append(fake.queryStringArgsForCall, struct {
	}{})
	stub := fake.QueryStringStub
	fakeReturns := fake.queryStringReturns
	fake.recordInvocation("QueryString", []interface{}{})
	fake.queryStringMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) QueryStringCallCount() int {
	fake.queryStringMutex.RLock()
	defer fake.queryStringMutex.RUnlock()
	return len(fake.queryStringArgsForCall)
}

func (fake *FakeContext) QueryStringCalls(stub func() string) {
	fake.queryStringMutex.Lock()
	defer fake.queryStringMutex.Unlock()
	fake.QueryStringStub = stub
}

func (fake *FakeContext) QueryStringReturns(result1 string) {
	fake.queryStringMutex.Lock()
	defer fake.queryStringMutex.Unlock()
	fake.QueryStringStub = nil
	fake.queryStringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) QueryStringReturnsOnCall(i int, result1 string) {
	fake.queryStringMutex.Lock()
	defer fake.queryStringMutex.Unlock()
	fake.QueryStringStub = nil
	if fake.queryStringReturnsOnCall == nil {
		fake.queryStringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.queryStringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) RealIP() string {
	fake.realIPMutex.Lock()
	ret, specificReturn := fake.realIPReturnsOnCall[len(fake.realIPArgsForCall)]
	fake.realIPArgsForCall = append(fake.realIPArgsForCall, struct {
	}{})
	stub := fake.RealIPStub
	fakeReturns := fake.realIPReturns
	fake.recordInvocation("RealIP", []interface{}{})
	fake.realIPMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) RealIPCallCount() int {
	fake.realIPMutex.RLock()
	defer fake.realIPMutex.RUnlock()
	return len(fake.realIPArgsForCall)
}

func (fake *FakeContext) RealIPCalls(stub func() string) {
	fake.realIPMutex.Lock()
	defer fake.realIPMutex.Unlock()
	fake.RealIPStub = stub
}

func (fake *FakeContext) RealIPReturns(result1 string) {
	fake.realIPMutex.Lock()
	defer fake.realIPMutex.Unlock()
	fake.RealIPStub = nil
	fake.realIPReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) RealIPReturnsOnCall(i int, result1 string) {
	fake.realIPMutex.Lock()
	defer fake.realIPMutex.Unlock()
	fake.RealIPStub = nil
	if fake.realIPReturnsOnCall == nil {
		fake.realIPReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.realIPReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) Redirect(arg1 int, arg2 string) error {
	fake.redirectMutex.Lock()
	ret, specificReturn := fake.redirectReturnsOnCall[len(fake.redirectArgsForCall)]
	fake.redirectArgsForCall = append(fake.redirectArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.RedirectStub
	fakeReturns := fake.redirectReturns
	fake.recordInvocation("Redirect", []interface{}{arg1, arg2})
	fake.redirectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) RedirectCallCount() int {
	fake.redirectMutex.RLock()
	defer fake.redirectMutex.RUnlock()
	return len(fake.redirectArgsForCall)
}

func (fake *FakeContext) RedirectCalls(stub func(int, string) error) {
	fake.redirectMutex.Lock()
	defer fake.redirectMutex.Unlock()
	fake.RedirectStub = stub
}

func (fake *FakeContext) RedirectArgsForCall(i int) (int, string) {
	fake.redirectMutex.RLock()
	defer fake.redirectMutex.RUnlock()
	argsForCall := fake.redirectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) RedirectReturns(result1 error) {
	fake.redirectMutex.Lock()
	defer fake.redirectMutex.Unlock()
	fake.RedirectStub = nil
	fake.redirectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) RedirectReturnsOnCall(i int, result1 error) {
	fake.redirectMutex.Lock()
	defer fake.redirectMutex.Unlock()
	fake.RedirectStub = nil
	if fake.redirectReturnsOnCall == nil {
		fake.redirectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.redirectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Render(arg1 int, arg2 string, arg3 interface{}) error {
	fake.renderMutex.Lock()
	ret, specificReturn := fake.renderReturnsOnCall[len(fake.renderArgsForCall)]
	fake.renderArgsForCall = append(fake.renderArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.RenderStub
	fakeReturns := fake.renderReturns
	fake.recordInvocation("Render", []interface{}{arg1, arg2, arg3})
	fake.renderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) RenderCallCount() int {
	fake.renderMutex.RLock()
	defer fake.renderMutex.RUnlock()
	return len(fake.renderArgsForCall)
}

func (fake *FakeContext) RenderCalls(stub func(int, string, interface{}) error) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = stub
}

func (fake *FakeContext) RenderArgsForCall(i int) (int, string, interface{}) {
	fake.renderMutex.RLock()
	defer fake.renderMutex.RUnlock()
	argsForCall := fake.renderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) RenderReturns(result1 error) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = nil
	fake.renderReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) RenderReturnsOnCall(i int, result1 error) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = nil
	if fake.renderReturnsOnCall == nil {
		fake.renderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Request() *http.Request {
	fake.requestMutex.Lock()
	ret, specificReturn := fake.requestReturnsOnCall[len(fake.requestArgsForCall)]
	fake.requestArgsForCall = append(fake.requestArgsForCall, struct {
	}{})
	stub := fake.RequestStub
	fakeReturns := fake.requestReturns
	fake.recordInvocation("Request", []interface{}{})
	fake.requestMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) RequestCallCount() int {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	return len(fake.requestArgsForCall)
}

func (fake *FakeContext) RequestCalls(stub func() *http.Request) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = stub
}

func (fake *FakeContext) RequestReturns(result1 *http.Request) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	fake.requestReturns = struct {
		result1 *http.Request
	}{result1}
}

func (fake *FakeContext) RequestReturnsOnCall(i int, result1 *http.Request) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	if fake.requestReturnsOnCall == nil {
		fake.requestReturnsOnCall = make(map[int]struct {
			result1 *http.Request
		})
	}
	fake.requestReturnsOnCall[i] = struct {
		result1 *http.Request
	}{result1}
}

func (fake *FakeContext) Reset(arg1 *http.Request, arg2 http.ResponseWriter) {
	fake.resetMutex.Lock()
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct {
		arg1 *http.Request
		arg2 http.ResponseWriter
	}{arg1, arg2})
	stub := fake.ResetStub
	fake.recordInvocation("Reset", []interface{}{arg1, arg2})
	fake.resetMutex.Unlock()
	if stub != nil {
		fake.ResetStub(arg1, arg2)
	}
}

func (fake *FakeContext) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeContext) ResetCalls(stub func(*http.Request, http.ResponseWriter)) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = stub
}

func (fake *FakeContext) ResetArgsForCall(i int) (*http.Request, http.ResponseWriter) {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	argsForCall := fake.resetArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) Response() *echo.Response {
	fake.responseMutex.Lock()
	ret, specificReturn := fake.responseReturnsOnCall[len(fake.responseArgsForCall)]
	fake.responseArgsForCall = append(fake.responseArgsForCall, struct {
	}{})
	stub := fake.ResponseStub
	fakeReturns := fake.responseReturns
	fake.recordInvocation("Response", []interface{}{})
	fake.responseMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) ResponseCallCount() int {
	fake.responseMutex.RLock()
	defer fake.responseMutex.RUnlock()
	return len(fake.responseArgsForCall)
}

func (fake *FakeContext) ResponseCalls(stub func() *echo.Response) {
	fake.responseMutex.Lock()
	defer fake.responseMutex.Unlock()
	fake.ResponseStub = stub
}

func (fake *FakeContext) ResponseReturns(result1 *echo.Response) {
	fake.responseMutex.Lock()
	defer fake.responseMutex.Unlock()
	fake.ResponseStub = nil
	fake.responseReturns = struct {
		result1 *echo.Response
	}{result1}
}

func (fake *FakeContext) ResponseReturnsOnCall(i int, result1 *echo.Response) {
	fake.responseMutex.Lock()
	defer fake.responseMutex.Unlock()
	fake.ResponseStub = nil
	if fake.responseReturnsOnCall == nil {
		fake.responseReturnsOnCall = make(map[int]struct {
			result1 *echo.Response
		})
	}
	fake.responseReturnsOnCall[i] = struct {
		result1 *echo.Response
	}{result1}
}

func (fake *FakeContext) Scheme() string {
	fake.schemeMutex.Lock()
	ret, specificReturn := fake.schemeReturnsOnCall[len(fake.schemeArgsForCall)]
	fake.schemeArgsForCall = append(fake.schemeArgsForCall, struct {
	}{})
	stub := fake.SchemeStub
	fakeReturns := fake.schemeReturns
	fake.recordInvocation("Scheme", []interface{}{})
	fake.schemeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) SchemeCallCount() int {
	fake.schemeMutex.RLock()
	defer fake.schemeMutex.RUnlock()
	return len(fake.schemeArgsForCall)
}

func (fake *FakeContext) SchemeCalls(stub func() string) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = stub
}

func (fake *FakeContext) SchemeReturns(result1 string) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = nil
	fake.schemeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) SchemeReturnsOnCall(i int, result1 string) {
	fake.schemeMutex.Lock()
	defer fake.schemeMutex.Unlock()
	fake.SchemeStub = nil
	if fake.schemeReturnsOnCall == nil {
		fake.schemeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.schemeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeContext) Set(arg1 string, arg2 interface{}) {
	fake.setMutex.Lock()
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.SetStub
	fake.recordInvocation("Set", []interface{}{arg1, arg2})
	fake.setMutex.Unlock()
	if stub != nil {
		fake.SetStub(arg1, arg2)
	}
}

func (fake *FakeContext) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeContext) SetCalls(stub func(string, interface{})) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakeContext) SetArgsForCall(i int) (string, interface{}) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) SetCookie(arg1 *http.Cookie) {
	fake.setCookieMutex.Lock()
	fake.setCookieArgsForCall = append(fake.setCookieArgsForCall, struct {
		arg1 *http.Cookie
	}{arg1})
	stub := fake.SetCookieStub
	fake.recordInvocation("SetCookie", []interface{}{arg1})
	fake.setCookieMutex.Unlock()
	if stub != nil {
		fake.SetCookieStub(arg1)
	}
}

func (fake *FakeContext) SetCookieCallCount() int {
	fake.setCookieMutex.RLock()
	defer fake.setCookieMutex.RUnlock()
	return len(fake.setCookieArgsForCall)
}

func (fake *FakeContext) SetCookieCalls(stub func(*http.Cookie)) {
	fake.setCookieMutex.Lock()
	defer fake.setCookieMutex.Unlock()
	fake.SetCookieStub = stub
}

func (fake *FakeContext) SetCookieArgsForCall(i int) *http.Cookie {
	fake.setCookieMutex.RLock()
	defer fake.setCookieMutex.RUnlock()
	argsForCall := fake.setCookieArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetHandler(arg1 echo.HandlerFunc) {
	fake.setHandlerMutex.Lock()
	fake.setHandlerArgsForCall = append(fake.setHandlerArgsForCall, struct {
		arg1 echo.HandlerFunc
	}{arg1})
	stub := fake.SetHandlerStub
	fake.recordInvocation("SetHandler", []interface{}{arg1})
	fake.setHandlerMutex.Unlock()
	if stub != nil {
		fake.SetHandlerStub(arg1)
	}
}

func (fake *FakeContext) SetHandlerCallCount() int {
	fake.setHandlerMutex.RLock()
	defer fake.setHandlerMutex.RUnlock()
	return len(fake.setHandlerArgsForCall)
}

func (fake *FakeContext) SetHandlerCalls(stub func(echo.HandlerFunc)) {
	fake.setHandlerMutex.Lock()
	defer fake.setHandlerMutex.Unlock()
	fake.SetHandlerStub = stub
}

func (fake *FakeContext) SetHandlerArgsForCall(i int) echo.HandlerFunc {
	fake.setHandlerMutex.RLock()
	defer fake.setHandlerMutex.RUnlock()
	argsForCall := fake.setHandlerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetLogger(arg1 echo.Logger) {
	fake.setLoggerMutex.Lock()
	fake.setLoggerArgsForCall = append(fake.setLoggerArgsForCall, struct {
		arg1 echo.Logger
	}{arg1})
	stub := fake.SetLoggerStub
	fake.recordInvocation("SetLogger", []interface{}{arg1})
	fake.setLoggerMutex.Unlock()
	if stub != nil {
		fake.SetLoggerStub(arg1)
	}
}

func (fake *FakeContext) SetLoggerCallCount() int {
	fake.setLoggerMutex.RLock()
	defer fake.setLoggerMutex.RUnlock()
	return len(fake.setLoggerArgsForCall)
}

func (fake *FakeContext) SetLoggerCalls(stub func(echo.Logger)) {
	fake.setLoggerMutex.Lock()
	defer fake.setLoggerMutex.Unlock()
	fake.SetLoggerStub = stub
}

func (fake *FakeContext) SetLoggerArgsForCall(i int) echo.Logger {
	fake.setLoggerMutex.RLock()
	defer fake.setLoggerMutex.RUnlock()
	argsForCall := fake.setLoggerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetParamNames(arg1 ...string) {
	fake.setParamNamesMutex.Lock()
	fake.setParamNamesArgsForCall = append(fake.setParamNamesArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.SetParamNamesStub
	fake.recordInvocation("SetParamNames", []interface{}{arg1})
	fake.setParamNamesMutex.Unlock()
	if stub != nil {
		fake.SetParamNamesStub(arg1...)
	}
}

func (fake *FakeContext) SetParamNamesCallCount() int {
	fake.setParamNamesMutex.RLock()
	defer fake.setParamNamesMutex.RUnlock()
	return len(fake.setParamNamesArgsForCall)
}

func (fake *FakeContext) SetParamNamesCalls(stub func(...string)) {
	fake.setParamNamesMutex.Lock()
	defer fake.setParamNamesMutex.Unlock()
	fake.SetParamNamesStub = stub
}

func (fake *FakeContext) SetParamNamesArgsForCall(i int) []string {
	fake.setParamNamesMutex.RLock()
	defer fake.setParamNamesMutex.RUnlock()
	argsForCall := fake.setParamNamesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetParamValues(arg1 ...string) {
	fake.setParamValuesMutex.Lock()
	fake.setParamValuesArgsForCall = append(fake.setParamValuesArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.SetParamValuesStub
	fake.recordInvocation("SetParamValues", []interface{}{arg1})
	fake.setParamValuesMutex.Unlock()
	if stub != nil {
		fake.SetParamValuesStub(arg1...)
	}
}

func (fake *FakeContext) SetParamValuesCallCount() int {
	fake.setParamValuesMutex.RLock()
	defer fake.setParamValuesMutex.RUnlock()
	return len(fake.setParamValuesArgsForCall)
}

func (fake *FakeContext) SetParamValuesCalls(stub func(...string)) {
	fake.setParamValuesMutex.Lock()
	defer fake.setParamValuesMutex.Unlock()
	fake.SetParamValuesStub = stub
}

func (fake *FakeContext) SetParamValuesArgsForCall(i int) []string {
	fake.setParamValuesMutex.RLock()
	defer fake.setParamValuesMutex.RUnlock()
	argsForCall := fake.setParamValuesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetPath(arg1 string) {
	fake.setPathMutex.Lock()
	fake.setPathArgsForCall = append(fake.setPathArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetPathStub
	fake.recordInvocation("SetPath", []interface{}{arg1})
	fake.setPathMutex.Unlock()
	if stub != nil {
		fake.SetPathStub(arg1)
	}
}

func (fake *FakeContext) SetPathCallCount() int {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	return len(fake.setPathArgsForCall)
}

func (fake *FakeContext) SetPathCalls(stub func(string)) {
	fake.setPathMutex.Lock()
	defer fake.setPathMutex.Unlock()
	fake.SetPathStub = stub
}

func (fake *FakeContext) SetPathArgsForCall(i int) string {
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	argsForCall := fake.setPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetRequest(arg1 *http.Request) {
	fake.setRequestMutex.Lock()
	fake.setRequestArgsForCall = append(fake.setRequestArgsForCall, struct {
		arg1 *http.Request
	}{arg1})
	stub := fake.SetRequestStub
	fake.recordInvocation("SetRequest", []interface{}{arg1})
	fake.setRequestMutex.Unlock()
	if stub != nil {
		fake.SetRequestStub(arg1)
	}
}

func (fake *FakeContext) SetRequestCallCount() int {
	fake.setRequestMutex.RLock()
	defer fake.setRequestMutex.RUnlock()
	return len(fake.setRequestArgsForCall)
}

func (fake *FakeContext) SetRequestCalls(stub func(*http.Request)) {
	fake.setRequestMutex.Lock()
	defer fake.setRequestMutex.Unlock()
	fake.SetRequestStub = stub
}

func (fake *FakeContext) SetRequestArgsForCall(i int) *http.Request {
	fake.setRequestMutex.RLock()
	defer fake.setRequestMutex.RUnlock()
	argsForCall := fake.setRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) SetResponse(arg1 *echo.Response) {
	fake.setResponseMutex.Lock()
	fake.setResponseArgsForCall = append(fake.setResponseArgsForCall, struct {
		arg1 *echo.Response
	}{arg1})
	stub := fake.SetResponseStub
	fake.recordInvocation("SetResponse", []interface{}{arg1})
	fake.setResponseMutex.Unlock()
	if stub != nil {
		fake.SetResponseStub(arg1)
	}
}

func (fake *FakeContext) SetResponseCallCount() int {
	fake.setResponseMutex.RLock()
	defer fake.setResponseMutex.RUnlock()
	return len(fake.setResponseArgsForCall)
}

func (fake *FakeContext) SetResponseCalls(stub func(*echo.Response)) {
	fake.setResponseMutex.Lock()
	defer fake.setResponseMutex.Unlock()
	fake.SetResponseStub = stub
}

func (fake *FakeContext) SetResponseArgsForCall(i int) *echo.Response {
	fake.setResponseMutex.RLock()
	defer fake.setResponseMutex.RUnlock()
	argsForCall := fake.setResponseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) Stream(arg1 int, arg2 string, arg3 io.Reader) error {
	fake.streamMutex.Lock()
	ret, specificReturn := fake.streamReturnsOnCall[len(fake.streamArgsForCall)]
	fake.streamArgsForCall = append(fake.streamArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 io.Reader
	}{arg1, arg2, arg3})
	stub := fake.StreamStub
	fakeReturns := fake.streamReturns
	fake.recordInvocation("Stream", []interface{}{arg1, arg2, arg3})
	fake.streamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) StreamCallCount() int {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	return len(fake.streamArgsForCall)
}

func (fake *FakeContext) StreamCalls(stub func(int, string, io.Reader) error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = stub
}

func (fake *FakeContext) StreamArgsForCall(i int) (int, string, io.Reader) {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	argsForCall := fake.streamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) StreamReturns(result1 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	fake.streamReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) StreamReturnsOnCall(i int, result1 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	if fake.streamReturnsOnCall == nil {
		fake.streamReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) String(arg1 int, arg2 string) error {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	stub := fake.StringStub
	fakeReturns := fake.stringReturns
	fake.recordInvocation("String", []interface{}{arg1, arg2})
	fake.stringMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeContext) StringCalls(stub func(int, string) error) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeContext) StringArgsForCall(i int) (int, string) {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	argsForCall := fake.stringArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) StringReturns(result1 error) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) StringReturnsOnCall(i int, result1 error) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Validate(arg1 interface{}) error {
	fake.validateMutex.Lock()
	ret, specificReturn := fake.validateReturnsOnCall[len(fake.validateArgsForCall)]
	fake.validateArgsForCall = append(fake.validateArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	stub := fake.ValidateStub
	fakeReturns := fake.validateReturns
	fake.recordInvocation("Validate", []interface{}{arg1})
	fake.validateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) ValidateCallCount() int {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	return len(fake.validateArgsForCall)
}

func (fake *FakeContext) ValidateCalls(stub func(interface{}) error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = stub
}

func (fake *FakeContext) ValidateArgsForCall(i int) interface{} {
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	argsForCall := fake.validateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeContext) ValidateReturns(result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	fake.validateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) ValidateReturnsOnCall(i int, result1 error) {
	fake.validateMutex.Lock()
	defer fake.validateMutex.Unlock()
	fake.ValidateStub = nil
	if fake.validateReturnsOnCall == nil {
		fake.validateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XML(arg1 int, arg2 interface{}) error {
	fake.xMLMutex.Lock()
	ret, specificReturn := fake.xMLReturnsOnCall[len(fake.xMLArgsForCall)]
	fake.xMLArgsForCall = append(fake.xMLArgsForCall, struct {
		arg1 int
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.XMLStub
	fakeReturns := fake.xMLReturns
	fake.recordInvocation("XML", []interface{}{arg1, arg2})
	fake.xMLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) XMLCallCount() int {
	fake.xMLMutex.RLock()
	defer fake.xMLMutex.RUnlock()
	return len(fake.xMLArgsForCall)
}

func (fake *FakeContext) XMLCalls(stub func(int, interface{}) error) {
	fake.xMLMutex.Lock()
	defer fake.xMLMutex.Unlock()
	fake.XMLStub = stub
}

func (fake *FakeContext) XMLArgsForCall(i int) (int, interface{}) {
	fake.xMLMutex.RLock()
	defer fake.xMLMutex.RUnlock()
	argsForCall := fake.xMLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) XMLReturns(result1 error) {
	fake.xMLMutex.Lock()
	defer fake.xMLMutex.Unlock()
	fake.XMLStub = nil
	fake.xMLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XMLReturnsOnCall(i int, result1 error) {
	fake.xMLMutex.Lock()
	defer fake.xMLMutex.Unlock()
	fake.XMLStub = nil
	if fake.xMLReturnsOnCall == nil {
		fake.xMLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.xMLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XMLBlob(arg1 int, arg2 []byte) error {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.xMLBlobMutex.Lock()
	ret, specificReturn := fake.xMLBlobReturnsOnCall[len(fake.xMLBlobArgsForCall)]
	fake.xMLBlobArgsForCall = append(fake.xMLBlobArgsForCall, struct {
		arg1 int
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.XMLBlobStub
	fakeReturns := fake.xMLBlobReturns
	fake.recordInvocation("XMLBlob", []interface{}{arg1, arg2Copy})
	fake.xMLBlobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) XMLBlobCallCount() int {
	fake.xMLBlobMutex.RLock()
	defer fake.xMLBlobMutex.RUnlock()
	return len(fake.xMLBlobArgsForCall)
}

func (fake *FakeContext) XMLBlobCalls(stub func(int, []byte) error) {
	fake.xMLBlobMutex.Lock()
	defer fake.xMLBlobMutex.Unlock()
	fake.XMLBlobStub = stub
}

func (fake *FakeContext) XMLBlobArgsForCall(i int) (int, []byte) {
	fake.xMLBlobMutex.RLock()
	defer fake.xMLBlobMutex.RUnlock()
	argsForCall := fake.xMLBlobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeContext) XMLBlobReturns(result1 error) {
	fake.xMLBlobMutex.Lock()
	defer fake.xMLBlobMutex.Unlock()
	fake.XMLBlobStub = nil
	fake.xMLBlobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XMLBlobReturnsOnCall(i int, result1 error) {
	fake.xMLBlobMutex.Lock()
	defer fake.xMLBlobMutex.Unlock()
	fake.XMLBlobStub = nil
	if fake.xMLBlobReturnsOnCall == nil {
		fake.xMLBlobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.xMLBlobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XMLPretty(arg1 int, arg2 interface{}, arg3 string) error {
	fake.xMLPrettyMutex.Lock()
	ret, specificReturn := fake.xMLPrettyReturnsOnCall[len(fake.xMLPrettyArgsForCall)]
	fake.xMLPrettyArgsForCall = append(fake.xMLPrettyArgsForCall, struct {
		arg1 int
		arg2 interface{}
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.XMLPrettyStub
	fakeReturns := fake.xMLPrettyReturns
	fake.recordInvocation("XMLPretty", []interface{}{arg1, arg2, arg3})
	fake.xMLPrettyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeContext) XMLPrettyCallCount() int {
	fake.xMLPrettyMutex.RLock()
	defer fake.xMLPrettyMutex.RUnlock()
	return len(fake.xMLPrettyArgsForCall)
}

func (fake *FakeContext) XMLPrettyCalls(stub func(int, interface{}, string) error) {
	fake.xMLPrettyMutex.Lock()
	defer fake.xMLPrettyMutex.Unlock()
	fake.XMLPrettyStub = stub
}

func (fake *FakeContext) XMLPrettyArgsForCall(i int) (int, interface{}, string) {
	fake.xMLPrettyMutex.RLock()
	defer fake.xMLPrettyMutex.RUnlock()
	argsForCall := fake.xMLPrettyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeContext) XMLPrettyReturns(result1 error) {
	fake.xMLPrettyMutex.Lock()
	defer fake.xMLPrettyMutex.Unlock()
	fake.XMLPrettyStub = nil
	fake.xMLPrettyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) XMLPrettyReturnsOnCall(i int, result1 error) {
	fake.xMLPrettyMutex.Lock()
	defer fake.xMLPrettyMutex.Unlock()
	fake.XMLPrettyStub = nil
	if fake.xMLPrettyReturnsOnCall == nil {
		fake.xMLPrettyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.xMLPrettyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.attachmentMutex.RLock()
	defer fake.attachmentMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.blobMutex.RLock()
	defer fake.blobMutex.RUnlock()
	fake.cookieMutex.RLock()
	defer fake.cookieMutex.RUnlock()
	fake.cookiesMutex.RLock()
	defer fake.cookiesMutex.RUnlock()
	fake.echoMutex.RLock()
	defer fake.echoMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	fake.formFileMutex.RLock()
	defer fake.formFileMutex.RUnlock()
	fake.formParamsMutex.RLock()
	defer fake.formParamsMutex.RUnlock()
	fake.formValueMutex.RLock()
	defer fake.formValueMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.hTMLMutex.RLock()
	defer fake.hTMLMutex.RUnlock()
	fake.hTMLBlobMutex.RLock()
	defer fake.hTMLBlobMutex.RUnlock()
	fake.handlerMutex.RLock()
	defer fake.handlerMutex.RUnlock()
	fake.inlineMutex.RLock()
	defer fake.inlineMutex.RUnlock()
	fake.isTLSMutex.RLock()
	defer fake.isTLSMutex.RUnlock()
	fake.isWebSocketMutex.RLock()
	defer fake.isWebSocketMutex.RUnlock()
	fake.jSONMutex.RLock()
	defer fake.jSONMutex.RUnlock()
	fake.jSONBlobMutex.RLock()
	defer fake.jSONBlobMutex.RUnlock()
	fake.jSONPMutex.RLock()
	defer fake.jSONPMutex.RUnlock()
	fake.jSONPBlobMutex.RLock()
	defer fake.jSONPBlobMutex.RUnlock()
	fake.jSONPrettyMutex.RLock()
	defer fake.jSONPrettyMutex.RUnlock()
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	fake.multipartFormMutex.RLock()
	defer fake.multipartFormMutex.RUnlock()
	fake.noContentMutex.RLock()
	defer fake.noContentMutex.RUnlock()
	fake.paramMutex.RLock()
	defer fake.paramMutex.RUnlock()
	fake.paramNamesMutex.RLock()
	defer fake.paramNamesMutex.RUnlock()
	fake.paramValuesMutex.RLock()
	defer fake.paramValuesMutex.RUnlock()
	fake.pathMutex.RLock()
	defer fake.pathMutex.RUnlock()
	fake.queryParamMutex.RLock()
	defer fake.queryParamMutex.RUnlock()
	fake.queryParamsMutex.RLock()
	defer fake.queryParamsMutex.RUnlock()
	fake.queryStringMutex.RLock()
	defer fake.queryStringMutex.RUnlock()
	fake.realIPMutex.RLock()
	defer fake.realIPMutex.RUnlock()
	fake.redirectMutex.RLock()
	defer fake.redirectMutex.RUnlock()
	fake.renderMutex.RLock()
	defer fake.renderMutex.RUnlock()
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	fake.responseMutex.RLock()
	defer fake.responseMutex.RUnlock()
	fake.schemeMutex.RLock()
	defer fake.schemeMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.setCookieMutex.RLock()
	defer fake.setCookieMutex.RUnlock()
	fake.setHandlerMutex.RLock()
	defer fake.setHandlerMutex.RUnlock()
	fake.setLoggerMutex.RLock()
	defer fake.setLoggerMutex.RUnlock()
	fake.setParamNamesMutex.RLock()
	defer fake.setParamNamesMutex.RUnlock()
	fake.setParamValuesMutex.RLock()
	defer fake.setParamValuesMutex.RUnlock()
	fake.setPathMutex.RLock()
	defer fake.setPathMutex.RUnlock()
	fake.setRequestMutex.RLock()
	defer fake.setRequestMutex.RUnlock()
	fake.setResponseMutex.RLock()
	defer fake.setResponseMutex.RUnlock()
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.validateMutex.RLock()
	defer fake.validateMutex.RUnlock()
	fake.xMLMutex.RLock()
	defer fake.xMLMutex.RUnlock()
	fake.xMLBlobMutex.RLock()
	defer fake.xMLBlobMutex.RUnlock()
	fake.xMLPrettyMutex.RLock()
	defer fake.xMLPrettyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ echo.Context = new(FakeContext)
